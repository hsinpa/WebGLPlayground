<html>
<head></head>

<body>
    <p>REGL Texture Sample</p>

    <canvas id="webgl" style="width: 45rem; height: 24rem;">

    </canvas>
</body>

<script src="library/regl.min.js"></script>

<script>
    var simpleFragPros = fetch("./glsl/simple_texture.frag", {method: 'GET'});
    var simpleVertPros = fetch("./glsl/simple_texture.vert", {method: 'GET'});


    let containerR = document.getElementById("webgl");    
    resizeCanvas(containerR);

    const regl = createREGL(containerR);

    let tick;

    const DrawTexturePrepareShader = function() {
        //Prepare 
        Promise.all([simpleVertPros, simpleFragPros, GetImagePromise("./image/BB_rank.PNG"), GetImagePromise("./image/nosie_cloud.jpg")])
        .then( responses =>
            Promise.all(
                [responses[0].text(), responses[1].text(), responses[2], responses[3]]
            )
        ).then((values) => {

            tick = regl.frame(function (context) {
                DrawTextureWithShader(values[0], values[1], values[2], values[3], context.time);
            })
        });
    }

    var DrawTextureWithShader = function(vert, frag, img, noiseTex, time) {
        // This clears the color buffer to black and the depth buffer to 1
        regl.clear({
        color: [0, 0, 0, 1],
        depth: 1
        })

        // In regl, draw operations are specified declaratively using. Each JSON
        // command is a complete description of all state. This removes the need to
        // .bind() things like buffers or shaders. All the boilerplate of setting up
        // and tearing down state is automated.
        regl( {
        // In a draw call, we can pass the shader source code to regl
        frag: frag,

        vert: vert,

        attributes: {
            a_position: [
                [-1, -1],
                [-1, 1],
                [1, 1],

                [-1, -1],
                [1, 1],
                [1, -1],
                ]

        },

        uniforms: {
            color: [1, 0, 0, 1],
            texture: regl.texture({data:img, flipY: true}),
            noiseTex : regl.texture({data:noiseTex, wrap  : "repeat"}),
            time : time
        },

        count: 6,
        })()
    }

    function resizeCanvas(canvas) {
        var width = canvas.clientWidth;
        var height = canvas.clientHeight;
        if (canvas.width != width ||
            canvas.height != height) {
            canvas.width = width;
            canvas.height = height;
        }
    }
    
    function GetImagePromise(imagePath) {
        //./image/BB_rank.PNG
        return new Promise(resolve => {
                    const im = new Image();
                    im.crossOrigin = "anonymous";
                    im.src =
                    imagePath;
                    im.onload = () => resolve(Object.assign(im, { style: "width:256px;height:256px;" }));
                });
    }


    DrawTexturePrepareShader();

</script>

</html>